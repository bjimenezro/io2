<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teoría de Colas</title>
    <link rel="stylesheet" href="styles/styles.css">
</head>
<body>
    <header>
        <h1>Teoría de Colas</h1>
        <nav>
            <ul>
                <li><a href="index.html">Inicio</a></li>
                <li><a href="teoria_colas.html">Teoría de Colas</a></li>
                <li><a href="programacion_dinamica.html">Programación Dinámica</a></li>
                <li><a href="programacion_no_lineal.html">Programación No Lineal</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <h2>Subtemas de Teoría de Colas</h2>
        <p>Explora los diferentes modelos y problemas relacionados con las líneas de espera:</p>
        <ul>
            <li><a href="#nacimiento-muerte">Esquema de nacimiento y muerte en sistema de colas</a></li>
            <li><a href="#modelo-mg1">Modelo de línea de espera con un servidor y tiempos de servicio arbitrarios</a></li>
            <li><a href="#mgcc">Modelo de múltiples servidores con tiempos de servicio arbitrarios y sin línea de espera</a></li>
            <li><a href="#problemas-asignacion">Problemas de asignación de recursos</a></li>
        </ul>

        <section id="nacimiento-muerte">
            <h3>Esquema de nacimiento y muerte (Teorema de Little con cadenas de Markov)</h3>
            <p>Analiza sistemas de colas basados en cadenas de Markov y el Teorema de Little.</p>
        
            <h4>Calculadora del esquema de nacimiento y muerte</h4>
            <form id="nacimiento-muerte-form">
                <label for="lambda">Tasa de llegada (\(\lambda\)):</label>
                <input type="number" id="lambda" step="any" required>
                <br>
                <label for="mu">Tasa de servicio (\(\mu\)):</label>
                <input type="number" id="mu" step="any" required>
                <br>
                <label for="n">Máximo número de estados (\(n\)):</label>
                <input type="number" id="n" min="1" required>
                <br>
                <button type="button" onclick="calcularNacimientoMuerte()">Calcular</button>
            </form>
        
            <div id="resultado-nacimiento-muerte" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Probabilidad de que el sistema esté vacío (\(P_0\)):</strong> <span id="p0-nm"></span></p>
                <p><strong>Número promedio en el sistema (\(L\)):</strong> <span id="l-nm"></span></p>
                <p><strong>Número promedio en la cola (\(L_q\)):</strong> <span id="lq-nm"></span></p>
                <p><strong>Tiempo promedio en el sistema (\(W\)):</strong> <span id="w-nm"></span></p>
                <p><strong>Tiempo promedio en la cola (\(W_q\)):</strong> <span id="wq-nm"></span></p>
            </div>
        </section>        

        <section id="modelo-mg1">
            <h3>Modelo de línea de espera con un servidor y tiempos de servicio arbitrarios (M/G/1)</h3>
            <p>Este modelo permite calcular métricas de desempeño cuando los tiempos de servicio no siguen una distribución exponencial, pero las llegadas son Poisson.</p>
        
            <h4>Calculadora del Modelo M/G/1</h4>
            <form id="mg1-form">
                <label for="lambda-mg1">Tasa de llegada (\(\lambda\)):</label>
                <input type="number" id="lambda-mg1" step="any" required>
                <br>
                <label for="mu-mg1">Tasa media de servicio (\(\mu\)):</label>
                <input type="number" id="mu-mg1" step="any" required>
                <br>
                <label for="sigma-mg1">Desviación estándar de los tiempos de servicio (\(\sigma\)):</label>
                <input type="number" id="sigma-mg1" step="any" required>
                <br>
                <button type="button" onclick="calcularMG1()">Calcular</button>
            </form>
        
            <div id="resultado-mg1" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Probabilidad de que el sistema esté vacío (\(P_0\)):</strong> <span id="p0-mg1"></span></p>
                <p><strong>Número promedio en la cola (\(L_q\)):</strong> <span id="lq-mg1"></span></p>
                <p><strong>Número promedio en el sistema (\(L\)):</strong> <span id="l-mg1"></span></p>
                <p><strong>Tiempo promedio en la cola (\(W_q\)):</strong> <span id="wq-mg1"></span></p>
                <p><strong>Tiempo promedio en el sistema (\(W\)):</strong> <span id="w-mg1"></span></p>
            </div>            
        </section>               

        <section id="mgcc">
            <h3>Modelo de múltiples servidores con tiempos de servicio arbitrarios y sin línea de espera (M/G/c/c)</h3>
            <p>Este modelo evalúa sistemas con múltiples servidores y sin capacidad para una cola.</p>
        
            <h4>Calculadora del modelo M/G/c/c</h4>
            <form id="mgcc-form">
                <label for="lambda-mgcc">Tasa de llegada (\(\lambda\)):</label>
                <input type="number" id="lambda-mgcc" step="any" required>
                <br>
                <label for="mu-mgcc">Tasa de servicio (\(\mu\)):</label>
                <input type="number" id="mu-mgcc" step="any" required>
                <br>
                <label for="c-mgcc">Número de servidores (\(c\)):</label>
                <input type="number" id="c-mgcc" min="1" required>
                <br>
                <button type="button" onclick="calcularMGCC()">Calcular</button>
            </form>
        
            <div id="resultado-mgcc" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Probabilidad de bloqueo (\(P_b\)):</strong> <span id="pb-mgcc"></span></p>
                <p><strong>Ocupación promedio (\(\rho\)):</strong> <span id="rho-mgcc"></span></p>
            </div>
        </section>              

        <section id="problemas-asignacion">
            <h3>Problemas de asignación de recursos</h3>
            <p>Los problemas de asignación de recursos buscan distribuir eficientemente recursos limitados entre tareas o actividades con base en criterios específicos, como minimizar costos o maximizar beneficios.</p>
        
            <h4>Calculadora de asignación (Método de costo mínimo)</h4>
            <p>Introduce una matriz cuadrada de costos donde cada celda representa el costo de asignar un recurso a una tarea.</p>
        
            <form id="asignacion-form">
                <label for="dimension">Dimensión de la matriz (N × N):</label>
                <input type="number" id="dimension" min="2" max="10" required>
                <button type="button" onclick="crearMatriz()">Crear Matriz</button>
            </form>
        
            <div id="matriz-container" style="margin-top: 20px; display: none;">
                <form id="matriz-form">
                    <div id="matriz"></div>
                    <button type="button" onclick="resolverAsignacion()">Resolver</button>
                </form>
            </div>
        
            <div id="resultado-asignacion" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Asignación Óptima:</strong></p>
                <ul id="asignacion-optima"></ul>
                <p><strong>Costo Total:</strong> <span id="costo-total"></span></p>
            </div>
        </section>        
    </main>
    <footer>
        <p>&copy; 2024 Investigación Operativa II</p>
    </footer>

    <script>
        function calcularMG1() {
            // Obtener valores del formulario
            const lambda = parseFloat(document.getElementById("lambda-mg1").value);
            const mu = parseFloat(document.getElementById("mu-mg1").value);
            const sigma = parseFloat(document.getElementById("sigma-mg1").value);

            // Validar entrada
            if (isNaN(lambda) || isNaN(mu) || isNaN(sigma) || lambda <= 0 || mu <= 0 || sigma < 0) {
                alert("Por favor, ingresa valores válidos para λ, μ y σ.");
                return;
            }

            const rho = lambda / mu;

            // Validar estabilidad
            if (rho >= 1) {
                alert("El sistema es inestable: λ debe ser menor que μ.");
                return;
            }

            // Cálculos del modelo M/G/1
            const p0 = 1 - rho; // Probabilidad de que el sistema esté vacío
            const lq = (Math.pow(lambda, 2) * Math.pow(sigma, 2) + Math.pow(rho, 2)) / (2 * (1 - rho)); // Número promedio en cola
            const l = lq + rho; // Número promedio en el sistema
            const wq = lq / lambda; // Tiempo promedio en cola
            const w = l / lambda; // Tiempo promedio en el sistema

            // Mostrar resultados
            document.getElementById("p0-mg1").textContent = p0.toFixed(4);
            document.getElementById("lq-mg1").textContent = lq.toFixed(2);
            document.getElementById("l-mg1").textContent = l.toFixed(2);
            document.getElementById("wq-mg1").textContent = wq.toFixed(2);
            document.getElementById("w-mg1").textContent = w.toFixed(2);

            document.getElementById("resultado-mg1").style.display = "block";
        }

        function calcularNacimientoMuerte() {
            const lambda = parseFloat(document.getElementById("lambda").value);
            const mu = parseFloat(document.getElementById("mu").value);
            const n = parseInt(document.getElementById("n").value);

            // Validar entrada
            if (isNaN(lambda) || isNaN(mu) || isNaN(n) || lambda <= 0 || mu <= 0 || n < 1) {
                alert("Por favor, ingresa valores válidos.");
                return;
            }

            // Cálculo de probabilidades estacionarias
            let p0 = 1;
            for (let i = 1; i <= n; i++) {
                p0 += Math.pow(lambda / mu, i);
            }
            p0 = 1 / p0;

            // Cálculo de métricas del sistema
            let l = 0; // Número promedio en el sistema
            for (let i = 1; i <= n; i++) {
                l += i * p0 * Math.pow(lambda / mu, i);
            }
            const lq = l - lambda / mu; // Número promedio en la cola
            const w = l / lambda; // Tiempo promedio en el sistema
            const wq = lq / lambda; // Tiempo promedio en la cola

            // Mostrar resultados
            document.getElementById("p0-nm").textContent = p0.toFixed(4);
            document.getElementById("l-nm").textContent = l.toFixed(2);
            document.getElementById("lq-nm").textContent = lq.toFixed(2);
            document.getElementById("w-nm").textContent = w.toFixed(2);
            document.getElementById("wq-nm").textContent = wq.toFixed(2);

            document.getElementById("resultado-nacimiento-muerte").style.display = "block";
        }

        function calcularMGCC() {
            const lambda = parseFloat(document.getElementById("lambda-mgcc").value);
            const mu = parseFloat(document.getElementById("mu-mgcc").value);
            const c = parseInt(document.getElementById("c-mgcc").value);

            // Validar entrada
            if (isNaN(lambda) || isNaN(mu) || isNaN(c) || lambda <= 0 || mu <= 0 || c < 1) {
                alert("Por favor, ingresa valores válidos.");
                return;
            }

            // Cálculo de Erlang-B
            const rho = lambda / (c * mu); // Ocupación promedio
            let factorial = (n) => (n <= 1 ? 1 : n * factorial(n - 1)); // Factorial recursivo
            let erlangB = Math.pow(lambda / mu, c) / factorial(c);
            let denominator = 0;

            for (let k = 0; k <= c; k++) {
                denominator += Math.pow(lambda / mu, k) / factorial(k);
            }
            erlangB /= denominator; // Probabilidad de bloqueo

            // Mostrar resultados
            document.getElementById("pb-mgcc").textContent = erlangB.toFixed(4);
            document.getElementById("rho-mgcc").textContent = rho.toFixed(2);

            document.getElementById("resultado-mgcc").style.display = "block";
        }

    // Crear la matriz dinámica de entrada
    function crearMatriz() {
        const dimension = parseInt(document.getElementById("dimension").value);

        if (isNaN(dimension) || dimension < 2 || dimension > 10) {
            alert("Por favor, ingresa un tamaño válido para la matriz (entre 2 y 10).");
            return;
        }

        const matrizContainer = document.getElementById("matriz");
        matrizContainer.innerHTML = ""; // Limpiar matriz previa

        for (let i = 0; i < dimension; i++) {
            const row = document.createElement("div");
            row.style.marginBottom = "10px";
            for (let j = 0; j < dimension; j++) {
                const input = document.createElement("input");
                input.type = "number";
                input.step = "any";
                input.style.width = "60px";
                input.style.marginRight = "5px";
                input.required = true;
                input.setAttribute("data-row", i);
                input.setAttribute("data-col", j);
                row.appendChild(input);
            }
            matrizContainer.appendChild(row);
        }

        document.getElementById("matriz-container").style.display = "block";
    }

    // Resolver el problema de asignación usando un enfoque básico
    function resolverAsignacion() {
        const inputs = document.querySelectorAll("#matriz input");
        const dimension = parseInt(document.getElementById("dimension").value);

        // Construir la matriz de costos
        const matriz = Array.from({ length: dimension }, () => Array(dimension).fill(0));
        inputs.forEach((input) => {
            const row = parseInt(input.getAttribute("data-row"));
            const col = parseInt(input.getAttribute("data-col"));
            matriz[row][col] = parseFloat(input.value);
        });

        // Verificar que todos los valores sean válidos
        if (matriz.flat().some(isNaN)) {
            alert("Por favor, completa todos los valores de la matriz.");
            return;
        }

        // Aplicar método de costo mínimo (simplificado)
        const asignaciones = [];
        const filasOcupadas = new Set();
        const columnasOcupadas = new Set();
        let costoTotal = 0;

        while (asignaciones.length < dimension) {
            let minimo = Infinity;
            let filaSeleccionada = -1;
            let columnaSeleccionada = -1;

            // Encontrar el menor costo disponible
            for (let i = 0; i < dimension; i++) {
                if (filasOcupadas.has(i)) continue;
                for (let j = 0; j < dimension; j++) {
                    if (columnasOcupadas.has(j)) continue;
                    if (matriz[i][j] < minimo) {
                        minimo = matriz[i][j];
                        filaSeleccionada = i;
                        columnaSeleccionada = j;
                    }
                }
            }

            // Registrar la asignación
            asignaciones.push(`Recurso ${filaSeleccionada + 1} → Tarea ${columnaSeleccionada + 1}`);
            filasOcupadas.add(filaSeleccionada);
            columnasOcupadas.add(columnaSeleccionada);
            costoTotal += minimo;
        }

        // Mostrar resultados
        const asignacionOptima = document.getElementById("asignacion-optima");
        asignacionOptima.innerHTML = "";
        asignaciones.forEach((asignacion) => {
            const li = document.createElement("li");
            li.textContent = asignacion;
            asignacionOptima.appendChild(li);
        });

        document.getElementById("costo-total").textContent = costoTotal.toFixed(2);
        document.getElementById("resultado-asignacion").style.display = "block";
    }
    </script>
</body>
</html>
