<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teoría de Colas</title>
    <link rel="stylesheet" href="styles/styles.css">
</head>
<body>
    <header>
        <h1>Teoría de Colas</h1>
        <nav>
            <ul>
                <li><a href="index.html">Inicio</a></li>
                <li><a href="teoria_colas.html">Teoría de Colas</a></li>
                <li><a href="programacion_dinamica.html">Programación Dinámica</a></li>
                <li><a href="programacion_no_lineal.html">Programación No Lineal</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <h2>Subtemas de Teoría de Colas</h2>
        <p>Explora los diferentes modelos y problemas relacionados con las líneas de espera:</p>
        <ul>
            <li><a href="#modelo-un-servidor">Modelo de línea de espera con un servidor y llegadas Poisson y tiempos de servicio exponenciales</a></li>
            <li><a href="#modelo-multiples-servidores">Modelo de línea de espera con múltiples servidores y llegadas Poisson y tiempos de servicio exponenciales</a></li>
            <li><a href="#modelo-fuentes-finitas">Modelos de línea de espera con fuentes finitas</a></li>
            <li><a href="#problemas-asignacion">Problemas de asignación de recursos</a></li>
        </ul>

        <section id="modelo-un-servidor">
            <h3>Modelo de línea de espera con un servidor y llegadas Poisson y tiempos de servicio exponenciales</h3>
            <p>Este modelo describe una situación donde hay una sola estación de servicio y las llegadas de los clientes se distribuyen de forma Poisson, mientras que los tiempos de servicio tienen una distribución exponencial. Es conocido como el modelo <strong>M/M/1</strong>.</p>

            <h4>Calculadora del Modelo M/M/1</h4>
            <form id="mm1-form">
                <label for="lambda">Tasa de llegada (\(\lambda\)):</label>
                <input type="number" id="lambda" step="any" required>
                <br>
                <label for="mu">Tasa de servicio (\(\mu\)):</label>
                <input type="number" id="mu" step="any" required>
                <br>
                <button type="button" onclick="calcularMM1()">Calcular</button>
            </form>

            <div id="resultado-mm1" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Factor de utilización (rho):</strong> <span id="rho"></span></p>
                <p><strong>Número promedio en el sistema (L):</strong> <span id="l"></span></p>
                <p><strong>Tiempo promedio en el sistema (W):</strong> <span id="w"></span></p>
                <p><strong>Probabilidad de que el sistema esté vacío (P₀):</strong> <span id="p0"></span></p>
                <p><strong>Número esperado de clientes en la cola (Lq):</strong> <span id="lq"></span></p>
                <p><strong>Tiempo esperado en la cola (Wq):</strong> <span id="wq"></span></p>
            </div>
        </section>

        <section id="modelo-multiples-servidores">
            <h3>Modelo de línea de espera con múltiples servidores y llegadas Poisson y tiempos de servicio exponenciales</h3>
            <p>Este modelo, conocido como <strong>M/M/c</strong>, generaliza el modelo M/M/1 al incluir múltiples servidores. Se utiliza para analizar sistemas como centros de llamadas o filas de cajas en supermercados.</p>
        
            <h4>Calculadora del Modelo M/M/c</h4>
            <form id="mmc-form">
                <label for="lambda-c">Tasa de llegada (\(\lambda\)):</label>
                <input type="number" id="lambda-c" step="any" required>
                <br>
                <label for="mu-c">Tasa de servicio (\(\mu\)):</label>
                <input type="number" id="mu-c" step="any" required>
                <br>
                <label for="c">Número de servidores (\(c\)):</label>
                <input type="number" id="c" step="1" required>
                <br>
                <button type="button" onclick="calcularMMC()">Calcular</button>
            </form>
        
            <div id="resultado-mmc" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Factor de utilización (\(\rho\)):</strong> <span id="rho-c"></span></p>
                <p><strong>Probabilidad de que todos los servidores estén ocupados (\(P_0\)):</strong> <span id="p0"></span></p>
                <p><strong>Número promedio en el sistema (\(L\)):</strong> <span id="l-c"></span></p>
                <p><strong>Tiempo promedio en el sistema (\(W\)):</strong> <span id="w-c"></span></p>
            </div>
        </section>        

        <section id="modelos-fuentes-finitas">
            <h3>Modelos de línea de espera con fuentes finitas</h3>
            <p>Este modelo analiza sistemas donde el número de clientes potenciales es limitado, como máquinas esperando ser reparadas o empleados en un comedor.</p>
        
            <h4>Calculadora del Modelo M/M/1/K</h4>
            <form id="mm1k-form">
                <label for="lambda-k">Tasa de llegada (\(\lambda\)):</label>
                <input type="number" id="lambda-k" step="any" required>
                <br>
                <label for="mu-k">Tasa de servicio (\(\mu\)):</label>
                <input type="number" id="mu-k" step="any" required>
                <br>
                <label for="k">Número total de fuentes (\(K\)):</label>
                <input type="number" id="k" step="1" required>
                <br>
                <button type="button" onclick="calcularMM1K()">Calcular</button>
            </form>
        
            <div id="resultado-mm1k" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Probabilidad de que el sistema esté vacío (\(P_0\)):</strong> <span id="p0-k"></span></p>
                <p><strong>Número promedio en el sistema (\(L\)):</strong> <span id="l-k"></span></p>
                <p><strong>Tiempo promedio en el sistema (\(W\)):</strong> <span id="w-k"></span></p>
            </div>
        </section>        

        <section id="problemas-asignacion">
            <h3>Problemas de asignación de recursos</h3>
            <p>Los problemas de asignación de recursos buscan distribuir eficientemente recursos limitados entre tareas o actividades con base en criterios específicos, como minimizar costos o maximizar beneficios.</p>
        
            <h4>Calculadora de asignación (Método de costo mínimo)</h4>
            <p>Introduce una matriz cuadrada de costos donde cada celda representa el costo de asignar un recurso a una tarea.</p>
        
            <form id="asignacion-form">
                <label for="dimension">Dimensión de la matriz (N × N):</label>
                <input type="number" id="dimension" min="2" max="10" required>
                <button type="button" onclick="crearMatriz()">Crear Matriz</button>
            </form>
        
            <div id="matriz-container" style="margin-top: 20px; display: none;">
                <form id="matriz-form">
                    <div id="matriz"></div>
                    <button type="button" onclick="resolverAsignacion()">Resolver</button>
                </form>
            </div>
        
            <div id="resultado-asignacion" style="margin-top: 20px; display: none;">
                <h4>Resultados:</h4>
                <p><strong>Asignación Óptima:</strong></p>
                <ul id="asignacion-optima"></ul>
                <p><strong>Costo Total:</strong> <span id="costo-total"></span></p>
            </div>
        </section>        
    </main>
    <footer>
        <p>&copy; 2024 Investigación Operativa II</p>
    </footer>

    <script>
        function calcularMM1() {
            // Obtener valores del formulario
            const lambda = parseFloat(document.getElementById("lambda").value);
            const mu = parseFloat(document.getElementById("mu").value);

            // Validar entrada
            if (isNaN(lambda) || isNaN(mu) || lambda <= 0 || mu <= 0) {
                alert("Por favor, ingresa valores válidos para λ y μ.");
                return;
            }

            if (lambda >= mu) {
                alert("El sistema no es estable. La tasa de llegada (λ) debe ser menor que la tasa de servicio (μ).");
                return;
            }

            // Calcular métricas
            const rho = lambda / mu; // Utilización
            const l = rho / (1 - rho); // Número esperado de clientes en el sistema
            const w = 1 / (mu - lambda); // Tiempo esperado en el sistema
            const p0 = 1 - rho; // Probabilidad de que el sistema esté vacío
            const lq = (rho ** 2) / (1 - rho); // Número esperado de clientes en la cola
            const wq = rho / (mu - lambda); // Tiempo esperado en la cola

            // Mostrar resultados
            document.getElementById("rho").textContent = rho.toFixed(2);
            document.getElementById("l").textContent = l.toFixed(2);
            document.getElementById("w").textContent = w.toFixed(2);
            document.getElementById("p0").textContent = p0.toFixed(2);
            document.getElementById("lq").textContent = lq.toFixed(2);
            document.getElementById("wq").textContent = wq.toFixed(2);

            document.getElementById("resultado-mm1").style.display = "block";
        }

        function calcularMMC() {
        // Obtener valores del formulario
        const lambda = parseFloat(document.getElementById("lambda-c").value);
        const mu = parseFloat(document.getElementById("mu-c").value);
        const c = parseInt(document.getElementById("c").value);

        // Validar entrada
        if (isNaN(lambda) || isNaN(mu) || isNaN(c) || lambda <= 0 || mu <= 0 || c <= 0) {
            alert("Por favor, ingresa valores válidos para λ, μ y c.");
            return;
        }

        const rho = lambda / (c * mu);
        if (rho >= 1) {
            alert("El sistema no es estable. Asegúrate de que la tasa de llegada sea menor que la capacidad de servicio total.");
            return;
        }

        // Calcular P0 usando la fórmula de Erlang-C
        let sum = 0;
        for (let n = 0; n < c; n++) {
            sum += Math.pow(lambda / mu, n) / factorial(n);
        }
        const p0 = 1 / (sum + (Math.pow(lambda / mu, c) / (factorial(c) * (1 - rho))));

        // Calcular L y W
        const lq = (Math.pow(lambda / mu, c) * rho * p0) / (factorial(c) * Math.pow(1 - rho, 2));
        const l = lq + (lambda / mu);
        const w = l / lambda;

        // Mostrar resultados
        document.getElementById("rho-c").textContent = rho.toFixed(2);
        document.getElementById("p0").textContent = p0.toFixed(4);
        document.getElementById("l-c").textContent = l.toFixed(2);
        document.getElementById("w-c").textContent = w.toFixed(2);

        document.getElementById("resultado-mmc").style.display = "block";
        }

        // Función para calcular el factorial
        function factorial(n) {
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }

            function calcularMM1K() {
        // Obtener valores del formulario
        const lambda = parseFloat(document.getElementById("lambda-k").value);
        const mu = parseFloat(document.getElementById("mu-k").value);
        const k = parseInt(document.getElementById("k").value);

        // Validar entrada
        if (isNaN(lambda) || isNaN(mu) || isNaN(k) || lambda <= 0 || mu <= 0 || k <= 0) {
            alert("Por favor, ingresa valores válidos para λ, μ y K.");
            return;
        }

        const rho = lambda / mu;

        // Calcular P0
        let sum = 0;
        for (let n = 0; n <= k; n++) {
            sum += combination(k, n) * Math.pow(rho, n);
        }
        const p0 = 1 / sum;

        // Calcular L y W
        let l = 0;
        for (let n = 1; n <= k; n++) {
            l += n * combination(k, n) * Math.pow(rho, n) * p0;
        }
        const w = l / (lambda * (k - l / k));

        // Mostrar resultados
        document.getElementById("p0-k").textContent = p0.toFixed(4);
        document.getElementById("l-k").textContent = l.toFixed(2);
        document.getElementById("w-k").textContent = w.toFixed(2);

        document.getElementById("resultado-mm1k").style.display = "block";
    }

    // Función para calcular combinaciones
    function combination(n, r) {
        return factorial(n) / (factorial(r) * factorial(n - r));
    }

    // Función para calcular el factorial
    function factorial(n) {
        if (n === 0 || n === 1) return 1;
        let result = 1;
        for (let i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }

    // Crear la matriz dinámica de entrada
    function crearMatriz() {
        const dimension = parseInt(document.getElementById("dimension").value);

        if (isNaN(dimension) || dimension < 2 || dimension > 10) {
            alert("Por favor, ingresa un tamaño válido para la matriz (entre 2 y 10).");
            return;
        }

        const matrizContainer = document.getElementById("matriz");
        matrizContainer.innerHTML = ""; // Limpiar matriz previa

        for (let i = 0; i < dimension; i++) {
            const row = document.createElement("div");
            row.style.marginBottom = "10px";
            for (let j = 0; j < dimension; j++) {
                const input = document.createElement("input");
                input.type = "number";
                input.step = "any";
                input.style.width = "60px";
                input.style.marginRight = "5px";
                input.required = true;
                input.setAttribute("data-row", i);
                input.setAttribute("data-col", j);
                row.appendChild(input);
            }
            matrizContainer.appendChild(row);
        }

        document.getElementById("matriz-container").style.display = "block";
    }

    // Resolver el problema de asignación usando un enfoque básico
    function resolverAsignacion() {
        const inputs = document.querySelectorAll("#matriz input");
        const dimension = parseInt(document.getElementById("dimension").value);

        // Construir la matriz de costos
        const matriz = Array.from({ length: dimension }, () => Array(dimension).fill(0));
        inputs.forEach((input) => {
            const row = parseInt(input.getAttribute("data-row"));
            const col = parseInt(input.getAttribute("data-col"));
            matriz[row][col] = parseFloat(input.value);
        });

        // Verificar que todos los valores sean válidos
        if (matriz.flat().some(isNaN)) {
            alert("Por favor, completa todos los valores de la matriz.");
            return;
        }

        // Aplicar método de costo mínimo (simplificado)
        const asignaciones = [];
        const filasOcupadas = new Set();
        const columnasOcupadas = new Set();
        let costoTotal = 0;

        while (asignaciones.length < dimension) {
            let minimo = Infinity;
            let filaSeleccionada = -1;
            let columnaSeleccionada = -1;

            // Encontrar el menor costo disponible
            for (let i = 0; i < dimension; i++) {
                if (filasOcupadas.has(i)) continue;
                for (let j = 0; j < dimension; j++) {
                    if (columnasOcupadas.has(j)) continue;
                    if (matriz[i][j] < minimo) {
                        minimo = matriz[i][j];
                        filaSeleccionada = i;
                        columnaSeleccionada = j;
                    }
                }
            }

            // Registrar la asignación
            asignaciones.push(`Recurso ${filaSeleccionada + 1} → Tarea ${columnaSeleccionada + 1}`);
            filasOcupadas.add(filaSeleccionada);
            columnasOcupadas.add(columnaSeleccionada);
            costoTotal += minimo;
        }

        // Mostrar resultados
        const asignacionOptima = document.getElementById("asignacion-optima");
        asignacionOptima.innerHTML = "";
        asignaciones.forEach((asignacion) => {
            const li = document.createElement("li");
            li.textContent = asignacion;
            asignacionOptima.appendChild(li);
        });

        document.getElementById("costo-total").textContent = costoTotal.toFixed(2);
        document.getElementById("resultado-asignacion").style.display = "block";
    }
    </script>
</body>
</html>
